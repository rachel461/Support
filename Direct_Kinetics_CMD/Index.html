<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Direct Kinetics - CMD</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

    <style>
        /* --- BRAND PALETTE --- */
        :root {
            --nicoya-dark-blue: #212B38;
            --nicoya-light-blue: #67CBDF; /* Lanes */
            --nicoya-white: #FFFFFF;
            --nicoya-yellow: #E9C259; /* Mixers */
            --nicoya-light-grey: #F2F2F2;
            --nicoya-border: #E0E0E0;
            --sidebar-width: 280px;
            --topbar-height: 60px;
        }

        /* --- LAYOUT --- */
        body {
            font-family: 'Montserrat', 'Segoe UI', sans-serif;
            margin: 0; height: 100vh; width: 100vw;
            display: grid;
            grid-template-columns: var(--sidebar-width) 1fr var(--sidebar-width);
            grid-template-rows: var(--topbar-height) 1fr;
            grid-template-areas: "header header header" "left main right";
            overflow: hidden; background-color: #FAFAFA;
        }

        @media (max-width: 1100px) {
            body {
                grid-template-columns: var(--sidebar-width) 1fr;
                grid-template-rows: var(--topbar-height) 1fr 140px; 
                grid-template-areas: "header header" "left main" "left right";
            }
            .sidebar-right {
                border-left: none !important;
                border-top: 1px solid var(--nicoya-border);
                flex-direction: row !important;
                gap: 20px; padding: 0.5rem 1rem !important; align-items: flex-start;
            }
            .sidebar-right .details-header-group {
                min-width: 140px; margin-bottom: 0 !important;
                display: flex; flex-direction: column; justify-content: center; height: 100%;
            }
            .table-container { flex: 1; height: 100%; overflow-y: auto; }
            .data-table th { position: sticky; top: 0; background: white; z-index: 2; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        }

        header {
            grid-area: header;
            background-color: var(--nicoya-white);
            border-bottom: 1px solid var(--nicoya-border);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 1.5rem; z-index: 20; box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .brand { font-weight: 800; font-size: 1.2rem; color: var(--nicoya-dark-blue); }
        .config-panel { display: flex; gap: 1.5rem; align-items: center; }
        .config-group { display: flex; align-items: center; gap: 0.5rem; background: var(--nicoya-light-grey); padding: 0.4rem 0.8rem; border-radius: 6px; }
        .config-label { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; color: #777; }

        /* --- SIDEBARS --- */
        aside { background-color: var(--nicoya-white); overflow-y: auto; display: flex; flex-direction: column; z-index: 15; }
        .sidebar-left { grid-area: left; border-right: 1px solid var(--nicoya-border); }
        .sidebar-right { grid-area: right; border-left: 1px solid var(--nicoya-border); padding: 1.5rem; }

        .sidebar-header { padding: 1.2rem; font-size: 0.85rem; font-weight: 700; color: #999; text-transform: uppercase; letter-spacing: 1px; }
        .activity-list { list-style: none; padding: 0; margin: 0; }
        .activity-item { border-bottom: 1px solid #f5f5f5; }
        .activity-btn { width: 100%; padding: 0.9rem 1.2rem; background: none; border: none; text-align: left; font-weight: 600; color: var(--nicoya-dark-blue); cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background 0.2s; font-size: 0.9rem;}
        .activity-btn:hover { background-color: #f9f9f9; }
        .activity-item.open .activity-btn { background-color: #f0f7ff; color: var(--nicoya-light-blue); }
        .drop-list { list-style: none; padding: 0; margin: 0; background-color: #FAFAFA; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
        .activity-item.open .drop-list { max-height: 1000px; border-bottom: 1px solid var(--nicoya-border); }
        .drop-item { padding: 0.6rem 1.2rem 0.6rem 2.2rem; font-size: 0.8rem; color: #555; cursor: pointer; display: flex; align-items: center; gap: 0.6rem; transition: all 0.2s; }
        .drop-item:hover { background-color: #eee; }
        .drop-item.running { font-weight: 700; color: var(--nicoya-dark-blue); background-color: #e3f2fd; }
        .drop-indicator { width: 8px; height: 8px; border-radius: 50%; background-color: #ddd; margin-right: 8px; }

        .details-title { font-size: 1rem; font-weight: 800; color: var(--nicoya-dark-blue); margin-bottom: 0.5rem; }
        .details-subtitle { font-size: 0.8rem; color: #777; margin-bottom: 1.5rem; }
        
        .data-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .data-table th { text-align: left; padding: 8px; border-bottom: 2px solid var(--nicoya-border); color: #999; font-weight: 700; text-transform: uppercase; font-size: 0.7rem; }
        .data-table td { padding: 10px 8px; border-bottom: 1px solid #eee; color: #333; font-weight: 600; vertical-align: middle; }
        .source-tag { display: inline-block; padding: 4px 8px; border-radius: 4px; color: white; font-weight: 700; font-size: 0.75rem; min-width: 24px; text-align: center; margin-right: 4px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }

        /* --- SCALABLE CANVAS --- */
        main { 
            grid-area: main; background-color: #F0F2F5; position: relative; 
            overflow: hidden; display: flex; justify-content: center; align-items: center; 
        }

        #scaler { transform-origin: center center; width: 1280px; height: 800px; display: flex; justify-content: center; align-items: center; }
        .chip-card { background: white; width: 100%; height: 100%; border-radius: 20px; box-shadow: 0 20px 50px rgba(0,0,0,0.1); padding: 20px 40px; position: relative; display: flex; flex-direction: column; }
        
        /* LAYER STRATEGY:
           ----------------
           1. Mixers (z:5)  - Bottom
           2. Paths (z:8)   - Middle
           3. Wells (z:12)  - Top
           4. Drops (z:100) - Floating
        */
        
        /* Removed z-index from grid container to allow children to interleave with sibling SVG */
        .chip-grid { 
            display: grid; flex: 1; 
            grid-template-rows: 30px 80px 60px 20px 70px repeat(9, 1fr) 70px; 
            gap: 2px; 
            position: relative; 
            /* z-index: 2;  <-- REMOVED THIS */
        }

        /* SVG Paths: Z-Index 8 (Above Mixers, Below Wells) */
        #pathOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 8; }

        .mode-btn { border: 1px solid #ddd; background: white; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 700; }
        .mode-btn.active { background: var(--nicoya-dark-blue); color: white; border-color: var(--nicoya-dark-blue); }
        
        .switch { position: relative; display: inline-block; width: 32px; height: 18px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 18px; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 2px; bottom: 2px; background-color: white; border-radius: 50%; transition: .4s; }
        input:checked + .slider { background-color: var(--nicoya-light-blue); }
        input:checked + .slider:before { transform: translateX(14px); }

        .row-label { font-size: 14px; font-weight: 700; color: #aaa; display: flex; align-items: center; justify-content: flex-end; padding-right: 10px;}
        .cell { position: relative; display: flex; justify-content: center; align-items: center; }

        /* --- COMPONENT STYLES --- */

        /* Mixers: Z=5 (Below Paths) */
        .mixer { 
            width: 85%; height: 80%; 
            background-color: var(--nicoya-yellow);
            border-radius: 8px; 
            z-index: 5; 
            position: relative;
            background-image: radial-gradient(rgba(255,255,255,0.6) 20%, transparent 20%); 
            background-size: 10px 10px; 
        }

        /* Wells: Z=12 (Above Paths) */
        .well { border-radius: 50%; border: 3px solid var(--nicoya-dark-blue); background: white; display: flex; justify-content: center; align-items: center; font-weight: 800; color: var(--nicoya-dark-blue); z-index: 12; transition: all 0.3s; position: relative; }
        .well-s { width: 28px; height: 28px; font-size: 14px; }
        .well-r { width: 44px; height: 44px; font-size: 14px; background-color: var(--nicoya-white); }
        .well-bf { width: 48px; height: 48px; font-size: 15px; border-width: 4px; }
        
        /* Sensors: Z=12 (Above Paths) */
        .sensor-group { display: flex; gap: 6px; width: 80px; }
        .sensor { 
            flex: 1; height: 32px; 
            background: #000000; color: #FFFFFF;
            display: flex; justify-content: center; align-items: center; 
            font-size: 12px; font-weight: 800; border-radius: 3px; 
            z-index: 12; 
            transition: background-color 0.3s; 
            position: relative; 
        }

        /* Lanes: Z=12 (Above Paths) */
        .lane-box { 
            background: var(--nicoya-light-blue); 
            width: 90px; height: 24px; 
            display: flex; justify-content: center; align-items: center; 
            border-radius: 4px; font-size: 12px; font-weight: 700; 
            z-index: 12; position: relative; 
            color: #fff;
        }

        .gap-point { width: 0px; height: 0px; background: #bbb; border-radius: 50%; z-index: 12; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); position: relative; }

        /* Drops: Z=100 (Highest) */
        .liquid-drop { position: absolute; width: 14px; height: 14px; border-radius: 50%; z-index: 100; box-shadow: 0 3px 6px rgba(0,0,0,0.3); pointer-events: none; will-change: top, left; }
        .fluid-path { fill: none; stroke-width: 5; stroke-linecap: round; stroke-linejoin: round; opacity: 0.6; }
        
        #logPanel { position: absolute; bottom: 20px; right: 20px; background: rgba(33, 43, 56, 0.95); color: white; padding: 12px 20px; border-radius: 8px; font-size: 12px; z-index: 200; max-width: 300px; }
    </style>
</head>
<body>

    <header>
        <div class="brand">Fluidic Movements - Direct Kinetics on CMD</div>
        <div class="config-panel">
            
            <div class="config-group">
                <span class="config-label">Mode</span>
                <button class="mode-btn" onclick="setMode(4)" id="btn-4">4</button>
                <button class="mode-btn active" onclick="setMode(8)" id="btn-8">8</button>
                <button class="mode-btn" onclick="setMode(16)" id="btn-16">16</button>
            </div>
            <div class="config-group">
                <span class="config-label">Buffer Blanks</span>
                <label class="switch">
                    <input type="checkbox" id="blankToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="config-group">
                <span class="config-label">Auxiliary Buffer</span>
                <label class="switch">
                    <input type="checkbox" id="auxToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="config-group">
                <span class="config-label">Biotin-Avidin</span>
                <label class="switch">
                    <input type="checkbox" id="bioToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </header>

    <aside class="sidebar-left">
        <div class="sidebar-header">Workflow</div>
        <ul class="activity-list" id="activityList"></ul>
    </aside>

    <main id="mainContainer">
        <div id="scaler">
            <div class="chip-card" id="chipCard">
                <svg id="pathOverlay"></svg>
                <div id="chipGrid" class="chip-grid"></div>
            </div>
        </div>
        <div id="logPanel">System Ready</div>
    </main>

    <aside class="sidebar-right">
        <div class="details-header-group">
            <div class="details-title" id="detailsTitle">Step Details</div>
            <div class="details-subtitle" id="detailsSubtitle">Select a step to view mapping</div>
        </div>
        <div class="table-container">
            <table class="data-table">
                <thead>
                    <tr> <th>Source Well</th> <th>Sensors</th> <th>Lane</th> </tr>
                </thead>
                <tbody id="detailsTableBody"><tr><td colspan="3" style="text-align:center;color:#ccc;">Waiting...</td></tr></tbody>
            </table>
        </div>
    </aside>

    <script>
        // --- 1. CONFIG & COLORS ---
        const wellColors = {
            'R8': '#29B6F6', 'BF_LOCAL': '#29B6F6',
            'A1': '#F50057', 'A2': '#00E676', 
            'A3': '#6200EA', 'A4': '#304FFE', 
            'A5': '#D50000', 'A6': '#AA00FF', 'MixEDC': '#F50057',
            'R5': '#00C853', 'B_ROW': '#FF6D00',
            'R1': '#FFAB91', 'R2': '#FF9100', 'R3': '#FF5252', 'R4': '#FFD180',
            'Avidin': '#26C6DA',
            'A7': '#00B0FF', 'A8': '#0091EA', 
            'ANALYTE': '#AB47BC', 'BUFFER': '#29B6F6'
        };

        const getSourceColor = (wellId) => {
            const id = wellId.replace('well-', '');
            if(wellColors[id]) return wellColors[id];
            if(id.startsWith('B') && !id.startsWith('BF')) return wellColors['B_ROW'];
            if(id.startsWith('BF')) return wellColors['BF_LOCAL'];
            if(id.startsWith('R') && ['1','2','3','4'].includes(id[1])) return wellColors[`R${id[1]}`];
            if(id === 'R6') return wellColors['Avidin']; 
            
            let hash = 0;
            for (let i = 0; i < id.length; i++) hash = id.charCodeAt(i) + ((hash << 5) - hash);
            const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
            return "#" + "00000".substring(0, 6 - c.length) + c;
        }

        // --- 2. WORKFLOW ---
        const workflowDefs = [
            { id: 'Startup', steps: [ { label: 'Buffer' } ] },
            { id: 'Normalize', steps: [ { label: 'Normalization High' }, { label: 'Buffer' } ] },
            { id: 'Clean', steps: [ { label: 'Clean' }, { label: 'Buffer' } ] },
            
            { id: 'Build Surface', steps: [
                { label: 'EDC/NHS' }, { label: 'Buffer' }, { label: 'Ligand' },
                { label: 'Buffer' }, { label: 'Ethanolamine' }, { label: 'Buffer', forceBF: true }
            ]},
            
            { id: 'Build Avidin Surface', steps: [
                 { label: 'EDC/NHS' }, { label: 'Buffer' }, { label: 'Avidin' },
                 { label: 'Buffer' }, { label: 'Ethanolamine' }, { label: 'Buffer', forceBF: true }
            ]},
            
            { id: 'Immobilize Biotin Ligand', steps: [ { label: 'Bt-Ligand' }, { label: 'Buffer' } ] },
            
            { id: 'Conditioning', steps: [ { label: 'Regeneration' }, { label: 'Buffer', forceBF: true } ] },
            { id: 'Direct Kinetics', steps: [] }
        ];

        ['C', 'D', 'E', 'F', 'G', 'H', 'I'].forEach((row, idx) => {
            workflowDefs.find(a => a.id === 'Direct Kinetics').steps.push(
                { label: `Buffer Blank`, isBlank: true, roundRow: row }, 
                { label: `Analyte Round ${idx+1}`, roundRow: row },
                { label: `Buffer Round ${idx+1}` },
                { label: `Regeneration Round ${idx+1}` }
            );
        });

        // --- 3. STATE ---
        let activeColumns = [3,4,5,6];
        let currentMode = 8;
        let isAux = false;
        let isBioAvidin = false; 
        let showBlanks = false; 
        
        const gridEl = document.getElementById('chipGrid');
        const svgEl = document.getElementById('pathOverlay');
        const chipCardEl = document.getElementById('chipCard');
        const scalerEl = document.getElementById('scaler');
        const logPanel = document.getElementById('logPanel');
        const activityListEl = document.getElementById('activityList');
        const auxToggle = document.getElementById('auxToggle');
        const bioToggle = document.getElementById('bioToggle'); 
        const blankToggle = document.getElementById('blankToggle');
        const tableBodyEl = document.getElementById('detailsTableBody');
        const detailsTitleEl = document.getElementById('detailsTitle');
        const detailsSubtitleEl = document.getElementById('detailsSubtitle');

        // --- 4. DATA LOGIC ---
        function getSourcesForColumn(actId, step, colIndex, isAuxOn) {
            const stepName = step.label;

            if (step.forceBF || step.isBlank) {
                return [{ id: `well-BF${colIndex}`, off: 0, side: 'Both', type: 'buffer' }];
            }

            if (stepName.includes('Buffer')) {
                if (actId === 'Direct Kinetics') return [{ id: `well-BF${colIndex}`, off: 0, side: 'Both' }];
                return [{ id: isAuxOn ? 'well-R8' : `well-BF${colIndex}`, off: 0, side: 'Both' }];
            }
            
            if (stepName.includes('Normalize') || stepName === 'Normalization High') {
                return [{ id: (colIndex % 2 !== 0) ? 'well-A1' : 'well-A2', off: 0, side: 'Both' }];
            }

            if (actId === 'Direct Kinetics' && stepName.includes('Analyte')) {
                return [
                    { id: `well-${step.roundRow}${colIndex}`, off: -5, type: 'analyte', side: 'Both' },
                    { id: `well-BF${colIndex}`, off: 5, type: 'buffer', side: 'Both' }
                ];
            }
            if (stepName.includes('EDC/NHS')) return [ { id: 'well-A5', off: -5, side: 'Both' }, { id: 'well-A6', off: 5, side: 'Both' } ];
            if (stepName.includes('Ligand') || stepName === 'Bt-Ligand') {
                return [ 
                    { id: 'well-R5', off: -5, side: 'L' }, 
                    { id: `well-B${colIndex}`, off: 5, side: 'R' } 
                ];
            }
            const s1 = (colIndex * 2) - 1;
            if (stepName.includes('Regeneration')) {
                let rWell = 'well-R4';
                if ([1,2,9,10].includes(s1)) rWell = 'well-R1';
                else if ([3,4,11,12].includes(s1)) rWell = 'well-R2';
                else if ([5,6,13,14].includes(s1)) rWell = 'well-R3';
                return [{ id: rWell, off: 0, side: 'Both' }];
            }
            if (stepName.includes('Clean')) return [{ id: (colIndex % 2 !== 0) ? 'well-A3' : 'well-A4', off: 0, side: 'Both' }];
            if (stepName.includes('Ethanolamine')) return [{ id: (colIndex % 2 !== 0) ? 'well-A7' : 'well-A8', off: 0, side: 'Both' }];
            if (stepName.includes('Avidin')) return [{ id: 'well-R6', off: 0, side: 'Both' }];
            
            return [];
        }

        // --- 5. RENDER TABLE ---
function renderDetailsTable(actId, step) {
            detailsTitleEl.textContent = step.label;
            detailsSubtitleEl.textContent = actId;
            tableBodyEl.innerHTML = '';

            const isAnalyteStep = actId === 'Direct Kinetics' && step.label.includes('Analyte') && !step.isBlank;

            activeColumns.forEach((col, idx) => {
                let sources = getSourcesForColumn(actId, step, col, isAux);
            

                const logicalLane = idx + 1;
                const sensLeft = (idx * 2) + 1;
                const sensRight = (idx * 2) + 2;

                const createRow = (srcList) => {
                    const tr = document.createElement('tr');
                    const tdSrc = document.createElement('td');
                    srcList.forEach(src => {
                        // Pass 'isAnalyteStep' to force purple color if needed
                        tdSrc.appendChild(createSourceTag(src.id, isAnalyteStep && src.type === 'analyte'));
                    });
                    tr.appendChild(tdSrc);
                    // Sensors
                    const tdSens = document.createElement('td'); 
                    if(srcList.some(s => s.side === 'L')) tdSens.textContent = `${sensLeft}`;
                    else if(srcList.some(s => s.side === 'R')) tdSens.textContent = `${sensRight}`;
                    else tdSens.textContent = `${sensLeft}, ${sensRight}`;
                    tr.appendChild(tdSens);
                    // Lane
                    const tdCh = document.createElement('td'); tdCh.textContent = logicalLane; tr.appendChild(tdCh);
                    return tr;
                };

                const bothSources = sources.filter(s => s.side === 'Both' || !s.side);
                if (bothSources.length > 0) tableBodyEl.appendChild(createRow(bothSources));

                const leftSources = sources.filter(s => s.side === 'L');
                if (leftSources.length > 0) tableBodyEl.appendChild(createRow(leftSources));

                const rightSources = sources.filter(s => s.side === 'R');
                if (rightSources.length > 0) tableBodyEl.appendChild(createRow(rightSources));
            });
        }

        function createSourceTag(wellId, forceAnalyteColor = false) {
            const tag = document.createElement('span'); 
            tag.className = 'source-tag';
            
            if (forceAnalyteColor) {
                tag.style.backgroundColor = wellColors['ANALYTE'];
            } else {
                tag.style.backgroundColor = getSourceColor(wellId);
            }
            
            tag.textContent = wellId.replace('well-', '');
            return tag;
        }

        // --- 6. ANIMATION ENGINE ---
        function getLocalCoords(el) {
            let x = 0; let y = 0; let curr = el;
            while(curr && curr.id !== 'chipCard') {
                x += curr.offsetLeft; y += curr.offsetTop;
                curr = curr.offsetParent;
            }
            x += el.offsetWidth / 2; y += el.offsetHeight / 2;
            return { x, y };
        }

        function createDrop(el, color, offX = 0) {
            const d = document.createElement('div');
            d.className = 'liquid-drop'; d.style.backgroundColor = color;
            const c = getLocalCoords(el);
            d.style.left = (c.x + offX - 7) + 'px'; d.style.top = (c.y - 7) + 'px';
            chipCardEl.appendChild(d);
            return d;
        }

        const SPEED_PX_PER_SEC = 400; // Increased speed for serial dilution

        async function animateDirect(el, start, end, color, pref) {
            return new Promise(resolve => {
                el.style.left = (start.x - 7) + 'px'; el.style.top = (start.y - 7) + 'px';
                if(Math.abs(start.x - end.x) < 1 && Math.abs(start.y - end.y) < 1) { resolve(); return; }

                let elbow = (pref === 'x-first') ? { x: end.x, y: start.y } : { x: start.x, y: end.y };
                const d1 = Math.hypot(elbow.x - start.x, elbow.y - start.y);
                const d2 = Math.hypot(end.x - elbow.x, end.y - elbow.y);
                const totalDist = d1 + d2;
                if(totalDist < 1) { resolve(); return; }

                const duration = (totalDist / SPEED_PX_PER_SEC) * 1000;
                const keyframes = [];
                keyframes.push({ left: (start.x - 7) + 'px', top: (start.y - 7) + 'px', offset: 0 });
                if(d1 > 1 && d2 > 1) {
                    keyframes.push({ left: (elbow.x - 7) + 'px', top: (elbow.y - 7) + 'px', offset: d1/totalDist });
                }
                keyframes.push({ left: (end.x - 7) + 'px', top: (end.y - 7) + 'px', offset: 1 });

                const anim = el.animate(keyframes, { duration: duration, easing: 'linear', fill: 'forwards' });
                anim.onfinish = () => {
                    drawPathLine(start, elbow, end, color);
                    el.style.left = (end.x - 7) + 'px'; el.style.top = (end.y - 7) + 'px';
                    resolve();
                };
            });
        }

        function drawPathLine(p1, p2, p3, color) {
            const pts = `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`;
            const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            poly.setAttribute('points', pts); poly.setAttribute('class', 'fluid-path');
            poly.style.stroke = color; poly.style.fill = 'none';
            svgEl.appendChild(poly);
        }

        async function runStep(actId, step, uiEl) {
            document.querySelectorAll('.drop-item').forEach(el => el.classList.remove('running'));
            uiEl.classList.add('running');
            clearVisuals();
            renderDetailsTable(actId, step);
            logPanel.innerHTML = `Action: ${step.label}<br>Status: Initializing...`;

            let drops = [];
            activeColumns.forEach((col, idx) => {
                const sources = getSourcesForColumn(actId, step, col, isAux);
                sources.forEach(src => {
                    let color = getSourceColor(src.id);
                    if(actId === 'Direct Kinetics' && step.label.includes('Analyte')) {
                        if(src.type === 'analyte') color = wellColors['ANALYTE'];
                        if(src.type === 'buffer') color = wellColors['BUFFER'];
                    }
                    drops.push({ targetCol: col, sourceId: src.id, color: color, offset: src.off, type: src.type });
                });
            });

            if(drops.length === 0) { logPanel.innerHTML = "No active sources."; return; }

            // SOURCE WELL COLORING LOGIC
            drops.forEach(d => {
                const el = document.getElementById(d.sourceId);
                // "Source wells should be coloured with the drop that comes out of it"
                if(el) { 
                    el.style.backgroundColor = d.color; 
                    el.style.borderColor = d.color; 
                    el.style.color = '#fff'; 
                }
            });

            // 1. Move to Gap
            const p1 = drops.map(d => {
                const srcEl = document.getElementById(d.sourceId);
                const srcColNum = parseInt(d.sourceId.match(/\d+$/)[0]); 
                const gapEl = document.getElementById(`gap-${srcColNum}`);
                if(!srcEl || !gapEl || srcEl.style.visibility === 'hidden') return Promise.resolve();
                d.element = createDrop(srcEl, d.color, d.offset);
                const start = getLocalCoords(srcEl); start.x += d.offset;
                const end = getLocalCoords(gapEl); end.x += d.offset;
                return animateDirect(d.element, start, end, d.color, 'y-first');
            });
            await Promise.all(p1);

            // 2. Gap -> Align
            const p2 = drops.map(d => {
                if(!d.element) return Promise.resolve();
                const srcColNum = parseInt(d.sourceId.match(/\d+$/)[0]); 
                if(srcColNum === d.targetCol) return Promise.resolve();
                const gapStart = document.getElementById(`gap-${srcColNum}`);
                const gapEnd = document.getElementById(`gap-${d.targetCol}`);
                const start = getLocalCoords(gapStart); start.x += d.offset;
                const end = getLocalCoords(gapEnd); end.x += d.offset;
                return animateDirect(d.element, start, end, d.color, 'x-first');
            });
            await Promise.all(p2);

            // 3. Gap -> Mixer
            const p3 = drops.map(d => {
                if(!d.element) return Promise.resolve();
                const gapEl = document.getElementById(`gap-${d.targetCol}`);
                const mixEl = document.getElementById(`mix-${d.targetCol}`);
                const start = getLocalCoords(gapEl); start.x += d.offset;
                const end = getLocalCoords(mixEl); end.x += d.offset;
                return animateDirect(d.element, start, end, d.color, 'y-first');
            });
            await Promise.all(p3);

            // 4. Mixing / Split Logic
            await new Promise(r => setTimeout(r, 100));
            
            // SPECIAL LOGIC FOR ANALYTE SERIAL DILUTION
            if (actId === 'Direct Kinetics' && step.label.includes('Analyte') && !step.isBlank) {
                logPanel.innerHTML = `Action: Serial Dilution<br>Generating 5 concentrations...`;

                // Remove original drops
                drops.forEach(d => { if(d.element) d.element.remove(); });
                
                // Process each active column
                const dilutionPromises = activeColumns.map(async (col) => {
                    const mixer = document.getElementById(`mix-${col}`);
                    const center = getLocalCoords(mixer);
                    const sL = document.getElementById(`s-${col}-L`); 
                    const sR = document.getElementById(`s-${col}-R`); 
                    const endL = getLocalCoords(sL);
                    const endR = getLocalCoords(sR);
                    
                    const baseColor = wellColors['ANALYTE']; // Purple
                    
                    // Create 5 drops representing dilutions
                    const dilutionDrops = [];
                    for(let i=0; i<5; i++) {
                        const d = createDrop(mixer, baseColor, 0);
                        d.style.opacity = (0.2 + (i * 0.2)); // 20%, 40%, 60%, 80%, 100%
                        // Offset them vertically to see them
                        d.style.top = (parseFloat(d.style.top) - 16 + (i*8)) + 'px'; 
                        dilutionDrops.push(d);
                    }
                    
                    // Animate them sequentially
                    for(let i=0; i<5; i++) {
                        logPanel.innerHTML = `Action: Serial Dilution<br>Injecting Concentration ${i+1}/5`;
                        const dSrc = dilutionDrops[i];
                        
                        // Split into 2
                        const dL = createDrop(mixer, baseColor, 0); dL.style.opacity = dSrc.style.opacity;
                        const dR = createDrop(mixer, baseColor, 0); dR.style.opacity = dSrc.style.opacity;
                        // Match position
                        dL.style.top = dSrc.style.top; dR.style.top = dSrc.style.top;
                        
                        dSrc.remove(); // Remove the source drop from mixer pile

                        await Promise.all([
                            animateDirect(dL, {x:center.x, y: center.y - 16 + (i*8)}, endL, baseColor, 'x-first').then(() => {
                                sL.style.backgroundColor = baseColor;
                                sL.style.opacity = (0.2 + (i * 0.2));
                                dL.remove();
                            }),
                            animateDirect(dR, {x:center.x, y: center.y - 16 + (i*8)}, endR, baseColor, 'x-first').then(() => {
                                sR.style.backgroundColor = baseColor;
                                sR.style.opacity = (0.2 + (i * 0.2));
                                dR.remove();
                            })
                        ]);
                        
                        // Brief pause between injections
                        await new Promise(r => setTimeout(r, 200));
                    }
                });
                await Promise.all(dilutionPromises);
            } 
            else {
                // STANDARD MIXING LOGIC (EDC/NHS, Ligand, etc)
                const mixPromises = activeColumns.map(async (col) => { 
                    const colDrops = drops.filter(d => d.targetCol === col && d.element);
                    if(colDrops.length === 0) return;
                    const mixer = document.getElementById(`mix-${col}`);
                    
                    colDrops.forEach(d => {
                        d.element.style.transition = 'transform 0.4s, opacity 0.4s';
                        d.element.style.transform = 'scale(0.1)'; d.element.style.opacity = '0';
                    });
                    await new Promise(r => setTimeout(r, 450));
                    colDrops.forEach(d => d.element.remove());

                    const center = getLocalCoords(mixer);
                    const sL = document.getElementById(`s-${col}-L`); 
                    const sR = document.getElementById(`s-${col}-R`); 
                    const endL = getLocalCoords(sL);
                    const endR = getLocalCoords(sR);

                    if(step.label.includes('EDC/NHS')) {
                        const mixColor = wellColors['MixEDC'];
                        const dMix = createDrop(mixer, mixColor, 0);
                        await new Promise(r => setTimeout(r, 200)); dMix.remove();
                        const dL = createDrop(mixer, mixColor, 0); const dR = createDrop(mixer, mixColor, 0);
                        await Promise.all([
                            animateDirect(dL, center, endL, mixColor, 'x-first').then(() => { sL.style.backgroundColor = mixColor; dL.remove(); }),
                            animateDirect(dR, center, endR, mixColor, 'x-first').then(() => { sR.style.backgroundColor = mixColor; dR.remove(); })
                        ]);
                    }
                    else if(step.label.includes('Ligand') || step.label === 'Bt-Ligand') {
                        const dropR5 = colDrops.find(d => d.sourceId === 'well-R5');
                        const dropB  = colDrops.find(d => d.sourceId.startsWith('well-B'));
                        const pArr = [];
                        if(dropR5) {
                            const startL = { x: center.x - 4, y: center.y };
                            const dL = createDrop(mixer, dropR5.color, -4);
                            pArr.push(animateDirect(dL, startL, endL, dropR5.color, 'x-first').then(() => {
                                sL.style.backgroundColor = dropR5.color; dL.remove();
                            }));
                        }
                        if(dropB) {
                            const startR = { x: center.x + 4, y: center.y };
                            const dR = createDrop(mixer, dropB.color, 4);
                            pArr.push(animateDirect(dR, startR, endR, dropB.color, 'x-first').then(() => {
                                sR.style.backgroundColor = dropB.color; dR.remove();
                            }));
                        }
                        await Promise.all(pArr);
                    }
                    else {
                        const color = colDrops[0].color;
                        const dL = createDrop(mixer, color, 0); const dR = createDrop(mixer, color, 0);
                        await Promise.all([
                            animateDirect(dL, center, endL, color, 'x-first').then(() => { sL.style.backgroundColor = color; dL.remove(); }),
                            animateDirect(dR, center, endR, color, 'x-first').then(() => { sR.style.backgroundColor = color; dR.remove(); })
                        ]);
                    }
                });
                await Promise.all(mixPromises);
            }
            logPanel.innerHTML = `Action: ${step.label}<br>Status: Complete`;
        }

        function clearVisuals() {
            svgEl.innerHTML = '';
            document.querySelectorAll('.sensor').forEach(el => { el.style.backgroundColor = ''; el.style.opacity = 1; });
            document.querySelectorAll('.well').forEach(el => { el.style.backgroundColor = ''; el.style.borderColor = ''; el.style.color = ''; });
        }

        function resize() {
            const container = document.getElementById('mainContainer');
            if(!container) return;
            const cw = container.clientWidth; const ch = container.clientHeight;
            const scale = Math.min(cw / 1280, ch / 800) * 0.98;
            scalerEl.style.transform = `scale(${scale})`;
        }
        
        const resizeObserver = new ResizeObserver(() => requestAnimationFrame(resize));
        const mainContainer = document.getElementById('mainContainer');
        if(mainContainer) resizeObserver.observe(mainContainer);

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
            if(mode === 4) activeColumns = [4, 5];
            else if(mode === 8) activeColumns = [3, 4, 5, 6];
            else activeColumns = [1, 2, 3, 4, 5, 6, 7, 8];
            renderGrid();
        }

        function renderGrid() {
            clearVisuals(); gridEl.innerHTML = '';
            const cols = 8; gridEl.style.gridTemplateColumns = `8% repeat(${cols}, 1fr)`;
            
            const addRow = (label, type, param) => {
                const lbl = document.createElement('div'); lbl.className = 'row-label'; lbl.textContent = label; gridEl.appendChild(lbl);
                for(let c=1; c<=cols; c++) {
                    const cell = document.createElement('div'); cell.className = 'cell';
                    const isActive = activeColumns.includes(c);
                    
                    const isSampleRow = ['C','D','E','F','G','H','I'].includes(label) || type === 'well-bf';
                    if(isSampleRow && !isActive) {
                        cell.style.visibility = 'hidden'; 
                    }

                    let displayLabel = c; 
                    let displaySensorL = (c*2)-1;
                    let displaySensorR = c*2;

                    if (isActive) {
                        const logicalIndex = activeColumns.indexOf(c);
                        if (type === 'lane') displayLabel = logicalIndex + 1;
                        if (type === 'sensor') {
                            displaySensorL = (logicalIndex * 2) + 1;
                            displaySensorR = (logicalIndex * 2) + 2;
                        }
                    }

                    if(type === 'sensor' && isActive) cell.innerHTML = `<div class="sensor-group"><div class="sensor" id="s-${c}-L">${displaySensorL}</div><div class="sensor" id="s-${c}-R">${displaySensorR}</div></div>`;
                    else if(type === 'mixer' && isActive) cell.innerHTML = `<div class="mixer" id="mix-${c}"></div>`;
                    else if(type === 'lane') {
                        const labelText = isActive ? displayLabel : "";
                        cell.innerHTML = `<div class="lane-box" style="opacity:${isActive?1:0.3}">${labelText}</div>`;
                    }
                    else if(type === 'gap') cell.innerHTML = `<div class="gap-point" id="gap-${c}"></div>`;
                    else if(type === 'well-r') cell.innerHTML = `<div class="well well-r" id="well-R${c}">R${c}</div>`;
                    else if(type === 'well-s') cell.innerHTML = `<div class="well well-s" id="well-${param}${c}">${param}${c}</div>`;
                    else if(type === 'well-bf') cell.innerHTML = `<div class="well well-bf" id="well-BF${c}">BF${c}</div>`;
                    
                    gridEl.appendChild(cell);
                }
            };
            addRow('Sensors', 'sensor'); addRow('Mixer', 'mixer'); addRow('Lanes', 'lane'); addRow('', 'gap'); addRow('Reagents', 'well-r');
            ['A','B','C','D','E','F','G','H','I'].forEach(r => addRow(r, 'well-s', r)); addRow('Buffer', 'well-bf');
        }

        function renderSidebar() {
            activityListEl.innerHTML = '';
            workflowDefs.forEach(act => {
                if (isBioAvidin) {
                    if (act.id === 'Build Surface') return;
                } else {
                    if (act.id === 'Build Avidin Surface' || act.id === 'Immobilize Biotin Ligand') return;
                }

                const li = document.createElement('li'); li.className = 'activity-item';
                const btn = document.createElement('button'); btn.className = 'activity-btn'; btn.innerHTML = `<span>${act.id}</span> <span>&#9662;</span>`;
                btn.onclick = () => { document.querySelectorAll('.activity-item').forEach(i => i !== li && i.classList.remove('open')); li.classList.toggle('open'); };
                const ul = document.createElement('ul'); ul.className = 'drop-list';
                
                act.steps.forEach(step => {
                    if (step.isBlank && !showBlanks) return;

                    const dLi = document.createElement('li'); dLi.className = 'drop-item';
                    dLi.innerHTML = `<div class="drop-indicator"></div> ${step.label}`;
                    dLi.onclick = (e) => { e.stopPropagation(); runStep(act.id, step, dLi); };
                    ul.appendChild(dLi);
                });
                li.appendChild(btn); li.appendChild(ul); activityListEl.appendChild(li);
            });
        }
        
        function init() { 
            renderSidebar(); setMode(8); 
            auxToggle.addEventListener('change', (e) => { isAux = e.target.checked; clearVisuals(); logPanel.innerText = `Aux: ${isAux?'ON':'OFF'}`; }); 
            bioToggle.addEventListener('change', (e) => { 
                isBioAvidin = e.target.checked; clearVisuals(); renderSidebar(); 
                logPanel.innerText = `Bio-Avidin: ${isBioAvidin?'ON':'OFF'}`; 
            });
            blankToggle.addEventListener('change', (e) => {
                showBlanks = e.target.checked;
                renderSidebar();
                logPanel.innerText = `Buffer Blanks: ${showBlanks?'Visible':'Hidden'}`;
            });
            resize(); 
        }
        init();
    </script>
</body>
</html>